C++11多线程之join与detach
	1,在C++中，程序默认是只有一个MainThread运行的，其入口函数是主函数main()，其中若开辟了其他的新的子线程，对这些线程的处理方式 有两种：
	一种是join(),即MainThread在join的子线程没执行完的这段时间里，什么也不做，直到子线程执行完毕，才会继续向下执行。
	另一种是detach()，如果没有其他一些同步措施的话，此时子线程和MainThread完全分离，两个纯种自顾自的运行，MainThread可以不等子线程运行完，就提前结束。但如果主线程销毁，那些被detach的线程也会被挂起，此时子线程里面本应cout出来显示的内容也将不再显示。


C++11中的线程同步——std::lock_guard模板
	C++中，可以通过 构造 std::mutex的实例来创建互斥元，可通过调用其成员函数lock()和unlock()来实现加锁和解锁，然而这是不推荐的算法，因为这要求程序员在离开函数的每条代码径上都调用unlock()，包括由于异常所导致的在内。
	作为替代，标准库提供了std::lock_guard类模板，实现了互斥元的RAII惯用语法（资源获取即初始化）。该对象在构造时锁定 所给的互斥元，析构时解锁互换元，从面保证锁定的互斥元始终被正确解锁。


多进程
	关于fork()之后，发生了什么事情：
	由fork()创建的新进程被称为子进程。此函数被调用一次，但返回两次。两次返回的区别是子进程返回值是0,而父进程的返回值是新进程的进程ID，将子进程ID返回给父进程的理由是：因为一个进程的子进程可以多于一个，没有一个函数使一个进程可以获得其所有子进程的进程ID。对于子进程来说，之所以返回0给它，是因为它随时可以调用getpid()来获取自己的pid;也可以调用getppid()来获取父进程的id(进程id为0总是由交换进程使用，所以一个子进程的进程id不可能为0)。
	fork()之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像是兄弟关系，这2个进程共享代码空间，但是数据空间是相互独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同，也就是说，子进程是从fork()返回处开始执行的）。


C/C++程序编译的过程：
	1,预处理	展开头文件，宏定义，条件编译
	2,编译		将预处理后的文件翻译成汇编代码的过程
	3,汇编		将上一步生成的汇编代码翻译成对应的二进制机器码的过程
	4,链接		将生成目标文件和其引用的各种符号等生成一个完整的可执行程序的过程
			链接的时候会进行虚拟内存的重定向操作。


Linux关于静态库和动态库（共享库）
	Linux操作系统中，依据函数库是否被编译到程序内部，将库分为两大类，静态函数库动态函数库
	Linux下的函数库放在/lib或/usr/lib，头文件放在/usr/include中
	在既有静态库又有动态的情况下，默认使用动态库，如果强制使用静态库则需要加-static选项支持。
    静态库
	1，扩展名通常为libxxx.a
	2，静态库在编译时会直接整合到执行程序当中，因此用静态库编译成的文件会比较大。
	3,优点：用其编译成功的可执行文件可以独立执行，不需要再向外部要求读取函数库的内容。
	4,缺点：因为静态库是直接整合到可执行文件中，所以其改变时，整个可执行文件都要重新编译才能将新的函数库整合到程序中，所以升级静态库会比较麻烦。
	5, 生成命令：ar -rcs libname.a file1.o file2.o ... fileN.o
    动态库（共享库）	
	1，扩展名通常为libxxx.so
	2，动态函数库并未被整合到可执行文件中，而是当可执行文件可使用到函数库的机制时，程序才会去读取函数库来使用。使用动态库的可执行文件具有指向动态函数库的指针，不包含函数库内容，因此相比之下文件较小。尤其是在多人程序同时使用一个函数库的情况下，使用动态库可以大减少文件的空间。
	3,优点：由于 具体指向功能，所以动态库改变时并不影响程序，所以升级方便。
	4,缺点：使用动态库编译出来的文件不可以被独立执行，且可执行文件里的指针是固定的，即程序读取动态库的路径是一定的，所以动态库不可以随便移动或删除。
	5,生成命令： gcc -shared -fpic -o libname.so file1.c file2.c ... fileN.c



