C++11多线程之join与detach
	1,在C++中，程序默认是只有一个MainThread运行的，其入口函数是主函数main()，其中若开辟了其他的新的子线程，对这些线程的处理方式 有两种：
	一种是join(),即MainThread在join的子线程没执行完的这段时间里，什么也不做，直到子线程执行完毕，才会继续向下执行。
	另一种是detach()，如果没有其他一些同步措施的话，此时子线程和MainThread完全分离，两个纯种自顾自的运行，MainThread可以不等子线程运行完，就提前结束。但如果主线程销毁，那些被detach的线程也会被挂起，此时子线程里面本应cout出来显示的内容也将不再显示。


C++11中的线程同步——std::lock_guard模板
	C++中，可以通过 构造 std::mutex的实例来创建互斥元，可通过调用其成员函数lock()和unlock()来实现加锁和解锁，然而这是不推荐的算法，因为这要求程序员在离开函数的每条代码径上都调用unlock()，包括由于异常所导致的在内。
	作为替代，标准库提供了std::lock_guard类模板，实现了互斥元的RAII惯用语法（资源获取即初始化）。该对象在构造时锁定 所给的互斥元，析构时解锁互换元，从面保证锁定的互斥元始终被正确解锁。


多进程
	关于fork()之后，发生了什么事情：
	由fork()创建的新进程被称为子进程。此函数被调用一次，但返回两次。两次返回的区别是子进程返回值是0,而父进程的返回值是新进程的进程ID，将子进程ID返回给父进程的理由是：因为一个进程的子进程可以多于一个，没有一个函数使一个进程可以获得其所有子进程的进程ID。对于子进程来说，之所以返回0给它，是因为它随时可以调用getpid()来获取自己的pid;也可以调用getppid()来获取父进程的id(进程id为0总是由交换进程使用，所以一个子进程的进程id不可能为0)。
	fork()之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像是兄弟关系，这2个进程共享代码空间，但是数据空间是相互独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同，也就是说，子进程是从fork()返回处开始执行的）。


C/C++程序编译的过程：
	1,预处理	展开头文件，宏定义，条件编译
	2,编译		将预处理后的文件翻译成汇编代码的过程
	3,汇编		将上一步生成的汇编代码翻译成对应的二进制机器码的过程
	4,链接		将生成目标文件和其引用的各种符号等生成一个完整的可执行程序的过程
			链接的时候会进行虚拟内存的重定向操作。


Linux关于静态库和动态库（共享库）
	Linux操作系统中，依据函数库是否被编译到程序内部，将库分为两大类，静态函数库动态函数库
	Linux下的函数库放在/lib或/usr/lib，头文件放在/usr/include中
	在既有静态库又有动态的情况下，默认使用动态库，如果强制使用静态库则需要加-static选项支持。
    静态库
	1，扩展名通常为libxxx.a
	2，静态库在编译时会直接整合到执行程序当中，因此用静态库编译成的文件会比较大。
	3,优点：用其编译成功的可执行文件可以独立执行，不需要再向外部要求读取函数库的内容。
	4,缺点：因为静态库是直接整合到可执行文件中，所以其改变时，整个可执行文件都要重新编译才能将新的函数库整合到程序中，所以升级静态库会比较麻烦。
	5, 生成命令：ar -rcs libname.a file1.o file2.o ... fileN.o
    动态库（共享库）	
	1，扩展名通常为libxxx.so
	2，动态函数库并未被整合到可执行文件中，而是当可执行文件可使用到函数库的机制时，程序才会去读取函数库来使用。使用动态库的可执行文件具有指向动态函数库的指针，不包含函数库内容，因此相比之下文件较小。尤其是在多人程序同时使用一个函数库的情况下，使用动态库可以大减少文件的空间。
	3,优点：由于 具体指向功能，所以动态库改变时并不影响程序，所以升级方便。
	4,缺点：使用动态库编译出来的文件不可以被独立执行，且可执行文件里的指针是固定的，即程序读取动态库的路径是一定的，所以动态库不可以随便移动或删除。
	5,生成命令： gcc -shared -fpic -o libname.so file1.c file2.c ... fileN.c

find命令
	-mtime	-n + n 按文件更改时间来查找，-n指n天以内，+n指n天以前
	-atime		访问时间
	-ctime		创建时间

C++中的POD数据类型
	POD类型对象与C编程语言完全兼容。（引入private和virtual的都不是POD类型）
C++11中的新特性：=default和=delete	仅用于类的特殊成员函数，且该特殊成员函数无默认参数。
	即可以在类体里定义，也可以在类体外定义。
	=default  显式缺省，告知编译器生成函数默认的缺省版本（生成的是POD类型）
	=delete	  显式删除，告知编译器不生成函数默认缺少版本（后续如果重载此函数是非法的）
	


1,C++  explicit
	C++提供关键字explicit，阻止未经允许的构造函数进行隐式转换的发生。



2,左值，右值，左值引用，右值引用，
	左值：就是有名字的变量（对象），可以被赋值，可以在多条语句中使用。
	右值：就是临时变量（对象），没有名字，只能在一条语句中出现，不能被赋值。
	左值的声明符号为“＆”， 为了和左值区分，右值的声明符号为“＆＆”。

	右值引用的意义：
		直观意义：为临时变量续命，也就是为右值续命，因为右值在表达结束后就消亡了，如果想继续使用右值，那就会动用昂贵的拷贝构造函数。（《深入理解C＋＋11》）
		右值引用是用来支持转移语义的。转移语义可以将资源（堆，系统对象等）从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建，拷贝以及释放，能够大幅度提高C＋＋应用程序的性能。临时对象的维护（创建和销毁）对性能有严重影响。
		转移语义是和拷贝语义相对的，可以类比文件的剪切和拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。能过转移语义，临时对象中的资源能够转移其它的对象里。
		在现在有的C＋＋机制中， 我们可以定义拷贝构造函数和赋值函数。实现在转移语义，需要定义转移构造函数，还可以定义转移赋值操作符。对于右值的拷贝和赋值会调用转移构造函数和赋值操作符。如果转移构造函数和转移拷贝操作符没有定义，那么就遵循现有的机制，拷贝构造函数和赋值操作符会被调用。

3,	std::move, std::forward。
	std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率，改善性能。
	std::move 本身并不移动任何东西,它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以便于移动语义。等同于一个类型转换：static_cast<T&&>(lvalue).

	std::move实现，首先，通过右值引用传递模板实现，利用引用折叠原理将右值经过T&&传递类型保持不变还是右值，而左值经过T&&变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变。然后我们通过static_cast<>进行强制类型转换返回T&&右值引用，而static_cast<T>之所以能使用类型转换，是通过remove_reference<T>::type模板移除T&&，T&的引用，获取具体类型T。
	
	std::forward把其参数转换为右值，仅仅在那个参数被绑定到一个右值时。
	两者在运行时（runtime)都不做任何事。


3，override关键字
	override关键字，可以避免派生类中忘记重写虚函数的错误。


4,使用到的第三方库有gtest

5，reinterpret_cast强制类型转换符
	new_type a = reinterpret_cast<new_type>(value)
	将value的值转成new_type类型的值，a和value的值一样，比特位不变
	reinterpret_cast用在任意类型之间的转换；　以及指针与足够大的整数类型之间的转换；　从整数类型到指针类型，无视大小。

６，epoll原理
	在linux的网络编程中，很长的时间都在使用select来做事件触发。在新的linux内核中，有了一种替换它的机制，就是epoll。相比select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。而且select最多配置１０２４个fd。
	epoll_create(int size)	创建一个epollo的句柄，size用来告诉内核这个监听的数目一共有多大。
	epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)
	epoll事件注册函数，它不同于select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。
		epfd:	epoll_create()的返回值。
		op:		表示动作，三个宏表示，注册／修改／删除　EPOLL_CTL_ADD/MOD/DEL
		fd:		需要监听的fd.
		event:	告诉内核需要监听什么事

	epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
	等待事件的产生，类似于select()调用
		参数events用来从内核得到事件的集合
		maxevents告之内核这个events有多大，这个值不能大于epoll_create()中的size.
		参数timeout是超时时间（毫秒，０会立即返回，-1将不确定）。
	该函数返回需要处理的事件数目，如返回０表示已超时。

	水平触发和边缘触发模式的区别：
	１，读缓冲区刚开始是空的
	２，读缓冲区写入２ＫＢ的数据
	３，水平触发和边缘触发模式此时都会发出可读信号
	４，收到信号通知后，读取了１kb的数据，读缓冲区还剩余１kb数据
	５，水平触发会再次进行通知，而边缘触发不会再进行通知。
	边缘触发需要一次性的把缓冲区的数据读完为止，也就是一直读，直到读到EGAIN为止，EGAIN说明缓冲区已经空了，因为这一点，边缘触发需要设置文件句柄为非阻塞。
　	Ｒedis使用的是水平触发。

	select/poll会因为监听fd的数量增加而导致效率低下，因为它是轮询所有的fd,有数据就处理，没数据就跳过，所以fd的数量增加会降低效率；　而epoll只处理就绪的fd，它有一个就绪设备的队列，每次轮询该队列的数据，然后进行处理。	

7， C++11关键字noexcept
	noexpect关键字告诉编译器，函数不会发生异常，这有利于编译器对程序做更多优化。
	如果在运行时，noexcept函数向外抛出了异常，程序会直接终止，调用std::terminate()函数，该函数内部会调用std::abort()终止程序。

8,CMakeList.txt中增加编译-g选项
	add_definitions("-Wall -g")



9,docker的一些命令操作
	进入一个容器
		docker exec -it c7188be9bd7b /bin/bash
	拷贝一个文件到docker的窗口中
		docker cp 本地路径  窗口长ID：容器路径
	删除所有容器
		docker rm `docker ps -a -q`
	删除所有镜像
		docker rmi `docker images -q`

10,C++的返回值问题
	return index++;		返回的值实际上是index,并没有加1.

11, Vector的几个用法	
	std::distance(nums.begin(), nums.end())		读取容器的大小（个数）
	std::remove(nums.begin(), nums.end(), val)	去除容器中的某个数值

12,几个常用的ROS命令
	rostopic list	 查看当前的话题列表
	rostopic type topic-name	查看当前话题的消息类型
	rosmsg show message-type-name	查看当前消息的数据类型

13，线程池技术
	线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。
	线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。
	线程池的组成部分：
		1，线程池管理器：用于创建并管理线程，包括创建、销毁和添加新任务。
		2，工作线程：线程池中的线程，无任务时处于等待，可以循环执行任务。
		3，任务接口：每个任务必须实现的接口，供工作线程调度任务的执行。规定任务入口，收尾，任务状态。
		4，任务队列：用于存放没有处理的任务。提供一种缓冲机制。
	多线程技术主要解决处理器单元内多个线程执行问题，可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。

14, extern "C" 的作用
	extern "C"不但具有传统的声明外部变量的功能，还具有告知C＋＋链接器使用C函数规范来链接的功能，还具有告知C＋＋编译器使用C规范来命名的功能。

15，C＋＋纯虚函数与虚函数（2019-11-12 20:00）
	纯虚函数形为：	virtual void run() = 0;
	1，纯虚函数在基类中是一定没有定义的，只会在基类中声明，并且要求子类一定要重写该函数（不然会报错）
	2，纯虚函数目的是为了实现“运行时多态”，实现同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。
	3，“运行时多态”是指一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被称为“虚”函数。
	4，一个类，只要有纯虚函数就称为抽象类，一个抽象类只能作为基类，而且不能定义抽象类的对象，但是可以定义抽象类的指针，为的是，他可以指向派生类的对象实现多态。
	虚函数形为：		virtual void say();
	
	纯虚函数和虚函数的区别：
	1，对于虚函数来说，基类可以有定义，子类可以没有定义，也就是可以不重载。
	2，对于纯虚函数来说，基类必须无定义，子类必须有定义，也就是子类必须重载。

16，HTTP服务的过程（2019-11-12 20:00）
	
	




	


